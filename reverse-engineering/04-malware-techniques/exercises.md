# Exercises: Malware Techniques

## Exercise 3: Manual Unpacking (The "UPX" Challenge)
1.  **Setup:** Take a predictable binary (like standard `calc.exe` or your `secret.exe`) and pack it with UPX: `upx -9 secret.exe -o secret_packed.exe`.
2.  **Task:** DO NOT run `upx -d`. Open `secret_packed.exe` in **x64dbg** (or GDB on Linux).
    *   Find the logic that decompresses the code (look for a massive loop).
    *   Find the "Tail Jump" (JMP to the OEP - Original Entry Point).
    *   **Challenge:** Dump the memory *after* the jump to OEP and fix the Import Address Table (IAT) using **Scylla** (built into x64dbg) to make a working standalone binary.

## Exercise 5: The Config Extractor
1.  **Setup:** Create a Python script that generates a "fake malicious config" blob.
    ```python
    import struct
    # C2 IP: 192.168.1.50, Port: 8080
    config_data = b"192.168.1.50" + b"\x00" * 4 + struct.pack("<H", 8080)
    # Simple XOR key
    key = 0x5A
    encrypted = bytes([b ^ key for b in config_data])
    with open("malware_config.bin", "wb") as f:
        f.write(encrypted)
    ```
2.  **Scenario:** Imagine you have 10,000 files like this. You cannot open them one by one.
3.  **Task:** Write a Python script using `pefile` (if it were embedded in a PE) or standard file I/O to:
    *   Read the file.
    *   Statically decrypt it (Apply XOR 0x5A).
    *   Parse the IP and Port.
    *   Print them in JSON format.
